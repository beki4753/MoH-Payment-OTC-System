import React, { useEffect, useState } from 'react';
import { Box, Button, IconButton, Typography, useTheme } from '@mui/material';
import { tokens } from '../../theme';
import DownloadOutlinedIcon from '@mui/icons-material/DownloadOutlined';
import CreditCardIcon from '@mui/icons-material/CreditCard';
import PointOfSaleIcon from '@mui/icons-material/PointOfSale';
import PersonAddIcon from '@mui/icons-material/PersonAdd';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import { Header, LineChart, GeographyChart, BarChart, StatBox, ProgressCircle } from '../../components';

import { getTokenValue } from '../../services/user_service';
import api from '../../utils/api';
import jsPDF from 'jspdf';
import { useRef } from 'react';
import html2canvas from 'html2canvas';

// Formatter functions
const formatter = new Intl.NumberFormat('en-US', {
	style: 'currency',
	currency: 'ETB',
	minimumFractionDigits: 2,
});

const formatAccounting = (num) => {
	const formatted = formatter.format(Math.abs(num));
	return num < 0 ? `(${formatted})` : formatted;
};

const Dashboard = () => {
	const tokenValue = getTokenValue();
	const theme = useTheme();
	const colors = tokens(theme.palette.mode);
	const [isGenerating, setIsGenerating] = useState(false);
	const dashboardRef = useRef(null);

	const handleDownloadPDF = async () => {
		setIsGenerating(true);
		const doc = new jsPDF({
			orientation: 'landscape',
			unit: 'mm',
			format: 'a4',
		});

		const element = dashboardRef.current;
		const options = {
			scale: 2,
			useCORS: true,
			logging: true,
			backgroundColor: colors.primary[400],
		};

		try {
			const canvas = await html2canvas(element, options);
			const imgData = canvas.toDataURL('image/png');
			const pdfWidth = doc.internal.pageSize.getWidth();
			const pdfHeight = doc.internal.pageSize.getHeight();
			const imgWidth = pdfWidth - 20;
			const imgHeight = (canvas.height * imgWidth) / canvas.width;

			doc.setFontSize(20);
			doc.setTextColor(colors.blueAccent[500]);
			doc.text('Hospital Revenue Dashboard', pdfWidth / 2, 15, {
				align: 'center',
			});

			doc.setFontSize(12);
			doc.setTextColor(100);
			doc.text(`Generated on: ${new Date().toLocaleString()}`, pdfWidth / 2, 22, { align: 'center' });
			doc.text(`Generated by: ${tokenValue?.name}`, pdfWidth / 2, 28, {
				align: 'center',
			});

			doc.addImage(imgData, 'PNG', 10, 35, imgWidth, imgHeight);

			doc.setFontSize(10);
			doc.setTextColor(150);
			doc.text('© 2023 Hospital Payment System', pdfWidth / 2, pdfHeight - 10, {
				align: 'center',
			});

			doc.save(`Dashboard_Report_${new Date().toISOString().slice(0, 10)}.pdf`);
		} catch (error) {
			console.error('Error generating PDF:', error);
		} finally {
			setIsGenerating(false);
		}
	};

	const [totalSum, setTotalSum] = useState(0);
	const [totalUnc, setTotalUnc] = useState(0);
	const [todayTotal, setTodayTotal] = useState(0);
	// const [yesterdayTotal, setYesterdayTotal] = useState(0);
	const [trend, setTrend] = useState(0);
	const [trendpercent, setTrendPercent] = useState(0);

	const [transactionCountBy, setTransactionCountBy] = useState({});
	// const [totalUncollectedbycash, setTotalUncollectedbycash] = useState([]);
	const [pateintCount, setPatientcount] = useState({});
	const [collectionbycashier, setCollectionbycashier] = useState([]);
	// const [lastCollectedOn, setLastCollectedOn] = useState("");
	const [totalCollected, setTotalCollected] = useState(0);

	const today = new Date();
	const startDate = new Date(today);
	startDate.setDate(today.getDate() - 7);
	const yesterday = new Date(today);
	yesterday.setDate(today.getDate() - 1);

	const collectionnStartDate = new Date(today);
	collectionnStartDate.setDate(today.getDate() - 30);
	// Fetch uncollected data
	useEffect(() => {
		const fetchUncollected = async () => {
			try {
				const response1 = await api.get(`/Collection/rpt-uncollected`);

				const uncollectedData = response1?.data;

				const uncollected = uncollectedData
					? uncollectedData?.reduce((acc, payment) => {
							const { cashier, cashAmount } = payment;
							acc[cashier] = (acc[cashier] || 0) + parseFloat(cashAmount);
							return acc;
					  }, {})
					: [];

				const fetchCollectedData = async () => {
					try {
						const response2 = await api.put('/Collection/Get-all-Collection', {
							startDate: collectionnStartDate.toISOString().split('T')[0],
							endDate: today.toISOString().split('T')[0],
							user: tokenValue?.name,
							isCollected: 0,
						});

						// Group collected data by cashier and find their last collected date
						const collectedByCashier = response2?.data
							? response2?.data?.reduce((acc, item) => {
									if (
										!acc[item.casher] ||
										new Date(item.collectedOn) > new Date(acc[item.casher].date)
									) {
										acc[item.casher] = {
											date: item.collectedOn,
											amount: parseFloat(item.collectedAmount || 0),
										};
									}
									return acc;
							  }, {})
							: [];

						// Calculate total collected across all cashiers
						const totalCollected = response2?.data
							? response2?.data?.reduce((acc, item) => acc + parseFloat(item.collectedAmount || 0), 0)
							: [];

						return {
							collectedByCashier,
							totalCollected: totalCollected || 0,
						};
					} catch (error) {
						console.error('Error fetching collected data:', error);
						return { collectedByCashier: {}, totalCollected: 0 };
					}
				};

				const mapp = Object.entries(uncollected).map(([key, value]) => ({
					cashier: key,
					amount: value,
				}));

				const totalUnc = Object.values(uncollected)?.reduce((acc, value) => acc + value, 0);

				const { collectedByCashier, totalCollected } = await fetchCollectedData();

				// Map each cashier's uncollected amount with their specific last collected date
				const transform2 = mapp.map((prev) => ({
					...prev,
					date: collectedByCashier[prev.cashier]?.date || null,
					collectedAmount: collectedByCashier[prev.cashier]?.amount || 0,
				}));

				setCollectionbycashier(transform2);
				setTotalUnc(totalUnc);
				// setTotalUncollectedbycash(mapp);
				setTotalCollected(totalCollected);
			} catch (error) {
				console.error('Error fetching uncollected data:', error);
			}
		};

		fetchUncollected();
	}, [collectionnStartDate, tokenValue?.name]);

	// Fetch recent transactions
	useEffect(() => {
		const fetchData = async () => {
			try {
				const response = await api.put('/Payment/Get-all-Payment', {
					startDate: startDate.toISOString().split('T')[0],
					endDate: today.toISOString().split('T')[0],
					user: tokenValue?.name,
				});

				const recentPayments = response?.data
					? response?.data?.filter((payment) => {
							const paymentDate = new Date(payment.registeredOn).toISOString().split('T')[0];
							return (
								paymentDate >= startDate.toISOString().split('T')[0] &&
								paymentDate <= today.toISOString().split('T')[0]
							);
					  })
					: [];

				const summary = recentPayments
					.filter((item) => item.paymentType.toLowerCase() !== 'free of charge')
					.reduce((acc, payment) => {
						const { paymentType, paymentAmount } = payment;
						acc[paymentType] = (acc[paymentType] || 0) + parseFloat(paymentAmount);
						return acc;
					}, {});

				const totalSum = Object.values(summary).reduce((acc, value) => acc + value, 0);

				// Today's data
				const todayDateStr = today.toISOString().split('T')[0];

				const todayPayments = recentPayments.filter((payment) => {
					return (
						payment.registeredOn?.split('T')[0] === todayDateStr &&
						payment.paymentType.toLowerCase() !== 'free of charge'
					);
				});

				// Yesterday's data
				const yesterdayDateStr = yesterday.toISOString().split('T')[0];
				const yesterdayPayments = recentPayments.filter((payment) => {
					return (
						payment.registeredOn?.split('T')[0] === yesterdayDateStr &&
						payment.paymentType.toLowerCase() !== 'free of charge'
					);
				});

				// Amount calculations
				const todayTotal = todayPayments.reduce((acc, payment) => acc + parseFloat(payment.paymentAmount), 0);

				const yesterdayTotal = yesterdayPayments.reduce(
					(acc, payment) => acc + parseFloat(payment.paymentAmount),
					0
				);

				const trend =
					yesterdayTotal > 0 ? Math.abs((todayTotal - yesterdayTotal) / yesterdayTotal).toFixed(2) : '0';

				const trendpercent =
					yesterdayTotal > 0
						? `${Math.round(((todayTotal - yesterdayTotal) / yesterdayTotal) * 100)}%`
						: '0%';

				// Transaction count calculations
				const todayTransactionCount = todayPayments.length;
				const yesterdayTransactionCount = yesterdayPayments.length;
				const transactionTrend =
					yesterdayTransactionCount > 0
						? Math.abs(
								(todayTransactionCount - yesterdayTransactionCount) / yesterdayTransactionCount
						  ).toFixed(2)
						: '0';
				const transactionTrendPercent =
					yesterdayTransactionCount > 0
						? `${Math.round(
								((todayTransactionCount - yesterdayTransactionCount) / yesterdayTransactionCount) * 100
						  )}%`
						: '0%';

				// Patient count calculations
				const todayPatientCount = new Set(todayPayments.map((payment) => payment.patientCardNumber)).size;

				const yesterdayPatientCount = new Set(yesterdayPayments.map((payment) => payment.patientCardNumber))
					.size;
				const patientTrend =
					yesterdayPatientCount > 0
						? Math.abs((todayPatientCount - yesterdayPatientCount) / yesterdayPatientCount).toFixed(2)
						: '0';
				const patientTrendPercent =
					yesterdayPatientCount > 0
						? `${Math.round(((todayPatientCount - yesterdayPatientCount) / yesterdayPatientCount) * 100)}%`
						: '0%';

				// Set all states

				setTotalSum(totalSum);

				setTodayTotal(todayTotal);

				// setYesterdayTotal(yesterdayTotal);

				setTrend(trend);

				setTrendPercent(trendpercent);
				setTransactionCountBy({
					count: todayTransactionCount,
					trend: transactionTrend,
					trendPercent: transactionTrendPercent,
				});

				setPatientcount({
					count: todayPatientCount,
					trend: patientTrend,
					trendPercent: patientTrendPercent,
				});
			} catch (error) {
				console.error('Error fetching transaction data:', error);
			}
		};

		fetchData();
	}, [tokenValue?.name]);
	return (
		<div ref={dashboardRef} style={{ padding: '20px' }}>
			{/* PDF Header - Only visible in PDF */}
			<div style={{ display: 'none' }}>
				<h1>Hospital Revenue Dashboard</h1>
				<p>Generated on: {new Date().toLocaleString()}</p>
				<p>Generated by: {tokenValue?.name}</p>
			</div>

			{/* HEADER */}
			<Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
				<Header title="DASHBOARD" subtitle="Welcome to your dashboard" />
				<Box>
					<Button
						onClick={handleDownloadPDF}
						sx={{
							backgroundColor: colors.blueAccent[700],
							color: colors.grey[100],
							fontSize: '14px',
							fontWeight: 'bold',
							padding: '10px 20px',
							'&:hover': {
								backgroundColor: colors.blueAccent[900],
							},
						}}
						disabled={isGenerating}
					>
						<DownloadOutlinedIcon sx={{ mr: '10px' }} />
						{isGenerating ? 'Generating PDF...' : 'Download Reports'}
					</Button>
				</Box>
			</Box>

			{/* GRID & CHARTS */}
			<Box display="grid" gridTemplateColumns="repeat(12, 1fr)" gridAutoRows="140px" gap="20px">
				{/* ROW 1 - STAT CARDS */}
				{[
					{
						title: transactionCountBy.count || 0,
						subtitle: 'No of Transactions Today',
						icon: <CreditCardIcon sx={{ color: colors.greenAccent[600], fontSize: '26px' }} />,
						progress: transactionCountBy.trend || '0',
						increase: transactionCountBy.trendPercent || '0%',
					},
					{
						title: formatAccounting(todayTotal),
						subtitle: 'Total Revenue Today',
						icon: <PointOfSaleIcon sx={{ color: colors.greenAccent[600], fontSize: '26px' }} />,
						progress: trend,
						increase: trendpercent,
					},
					{
						title: pateintCount.count || 0,
						subtitle: 'Patient served Today',
						icon: <PersonAddIcon sx={{ color: colors.greenAccent[600], fontSize: '26px' }} />,
						progress: pateintCount.trend || '0',
						increase: pateintCount.trendPercent || '0%',
					},
					{
						title: formatAccounting(totalUnc),
						subtitle: 'Uncollected Cash from Cashier',
						icon: <AccountBalanceIcon sx={{ color: colors.greenAccent[600], fontSize: '26px' }} />,
					},
				].map((stat, index) => (
					<Box
						key={index}
						gridColumn="span 3"
						backgroundColor={colors.primary[400]}
						display="flex"
						alignItems="center"
						justifyContent="center"
					>
						<StatBox
							title={stat.title}
							subtitle={stat.subtitle}
							progress={stat.progress}
							increase={stat.increase}
							icon={stat.icon}
						/>
					</Box>
				))}

				{/* ROW 2 - REVENUE CHART */}
				<Box gridColumn="span 8" gridRow="span 2" backgroundColor={colors.primary[400]}>
					<Box mt="25px" p="0 30px" display="flex" justifyContent="space-between" alignItems="center">
						<Box>
							<Typography variant="h5" fontWeight="600" color={colors.grey[100]}>
								Revenue Generated from Last Week
							</Typography>
							<Typography variant="h3" fontWeight="bold" color={colors.greenAccent[500]}>
								{formatAccounting(totalSum)}
							</Typography>
						</Box>
						<Box>
							<IconButton>
								<DownloadOutlinedIcon sx={{ fontSize: '26px', color: colors.greenAccent[500] }} />
							</IconButton>
						</Box>
					</Box>
					<Box height="250px" m="-20px 0 0 0">
						<LineChart isDashboard={true} />
					</Box>
				</Box>

				{/* ROW 2 - UNCOLLECTED CASH BY CASHIER */}
				<Box gridColumn="span 4" gridRow="span 2" backgroundColor={colors.primary[400]} overflow="auto">
					<Box display="flex" justifyContent="space-between" alignItems="center" p="15px">
						<Typography color={colors.grey[100]} variant="h5" fontWeight="600">
							Uncollected Cash by Cashier
						</Typography>
					</Box>

					{/* Column Titles */}
					<Box
						display="flex"
						justifyContent="space-between"
						p="10px 15px"
						borderBottom={`2px solid ${colors.primary[500]}`}
					>
						<Typography color={colors.greenAccent[500]} fontWeight="600" width="33%">
							Cashier Name
						</Typography>
						<Typography color={colors.greenAccent[500]} fontWeight="600" width="33%">
							Last Collection Date
						</Typography>
						<Typography color={colors.greenAccent[500]} fontWeight="600" width="33%">
							Total Amount
						</Typography>
					</Box>

					{collectionbycashier.map((transaction, i) => (
						<Box
							key={`${transaction.cashier}-${i}`}
							display="flex"
							justifyContent="space-between"
							alignItems="center"
							p="10px 15px"
							sx={{
								'&:hover': {
									backgroundColor: colors.greenAccent[900],
								},
							}}
						>
							<Typography color={colors.grey[100]} width="33%">
								{transaction.cashier}
							</Typography>
							<Typography color={colors.grey[100]} width="33%">
								{transaction.date ? new Date(transaction.date).toLocaleDateString() : 'N/A'}
							</Typography>
							<Typography color={colors.greenAccent[500]} fontWeight="600" width="33%">
								{formatAccounting(transaction.amount)}
							</Typography>
						</Box>
					))}
				</Box>

				{/* ROW 3 - PAYMENT METHOD CHART */}
				<Box
					gridColumn="span 3"
					gridRow="span 2"
					backgroundColor={colors.primary[400]}
					p="30px"
					overflow="auto"
				>
					<Typography variant="h5" fontWeight="600">
						Uncollected vs Collected Over Last Month
					</Typography>
					<Box display="flex" flexDirection="column" alignItems="center" mt="25px">
						<ProgressCircle
							progress={totalUnc + totalCollected > 0 ? totalCollected / (totalUnc + totalCollected) : 0} // the pie chart for collected and uncollected
							size="125"
							showLegend={true}
						/>
						<Typography variant="h5" color={colors.greenAccent[500]} sx={{ mt: '15px' }}>
							{formatAccounting(totalUnc)} of {formatAccounting(totalUnc + totalCollected)} is Uncollected
							from Cashier
						</Typography>
					</Box>
				</Box>

				<Box gridColumn="span 5" gridRow="span 2" backgroundColor={colors.primary[400]}>
					<Typography
						variant="h5"
						fontWeight="600"
						sx={{ padding: '30px 30px 0 30px' }}
						color={colors.grey[100]}
					>
						Amount by Payment Method over last week
					</Typography>
					<Box height="250px" mt="-20px">
						<BarChart isDashboard={true} />
					</Box>
				</Box>

				{/* ROW 3 - GEOGRAPHY CHART */}

				<Box gridColumn="span 4" gridRow="span 2" backgroundColor={colors.primary[400]} padding="30px">
					<Typography variant="h5" fontWeight="600" color={colors.grey[100]}>
						Geography Based Traffic
					</Typography>
					<Box height="200px" mt="10px">
						<GeographyChart isDashboard={true} />
					</Box>
				</Box>
			</Box>

			{/* PDF Footer - Only visible in PDF */}
			<div style={{ display: 'none' }}>
				<p style={{ textAlign: 'center', marginTop: '20px', color: '#666' }}>
					© {new Date().getFullYear()} Hospital Payment System - Confidential Report
				</p>
			</div>
		</div>
	);
};

export default Dashboard;
